/*
  This is an interactive (manual) version of telios (hence mantel), my implementation 
  of Numerical Recipes' downhill simplex method for function minimization.

  Usage: mantel <list of initial parameters>

  So e.g. if you are minimizing y(x1, x2, x3) then you will invoke mantel with:

    mantel x10 x20 x30

  Mantel then gives you a lists of parameters and prompts you for the corresponding
  value of y for this list.

  tjbc 10/8/2014
*/

#include <stdio.h>
#include <math.h>
#include <stdlib.h>
#include <string.h>
#include "mylib.h"        // utility functions
#include "myConstants.h"  // constants

static const int MAXSTR=10000; // maximum string size
static const bool DEBUG=false;

enum dataModeType { commandLine, script, fileMap, function } dataMode;
enum plotModeType { tecplot, gnuplot } plotMode;

// The parameters surrounding the problem are gathered into this container:
struct optionType {
    dataModeType dataMode;
    plotModeType plotMode;

    int    Ndim;                // Dimensionality of the function being optimized
    int    mapSize;             // size of the (square) map (if used)

    char   script[MAXSTR];      // name of the (optional) shell script called to generate y() values
    char   mapFile[MAXSTR];     // name of the (optional) map file
    char   logFile[MAXSTR];     // name of log file recording the simplex steps

    double **f;                 // the terrain map array. It's global to make it available to y(). Yes, that's bad.

    FILE   *fplot;              // the plotting output file showing the path of the simplex
    FILE   *flog;               // A log file generated by mantel
} o;

// The main simplex routine:
double amoeba(double **vlist,           // an array of ndim+1 vectors for the vertices of the simplex (ea. with ndim coords)
	      double *y,                // the initial values of the function at the vertices
	      int ndim,                 // the dimensionality of the space
	      double ftol,              // the tolerance for convergence
	      double (*funk)(double *), // function being optimized
	      int &nfunk,               // number of times the function was evaluated
	      int maxIters,             // max number of iterations
	      double *final);           // coordinates of the final optimized point

int main(int argc, char **argv) {
    double tol = 1.0e-4;
    double *v;       // The point around which the simplex is generated
    double **vlist;  // initial set of simplex vertices generated from v
    double *f0;      // initial set of function values at the simplex vertices
    double finalVal; // Optimized function value
    double *finalv;  // Final point coordinates
    int nEvals;      // number of times the function was evaluated during the optimization
    int  i;
    int firstArg;
    double y(double *v);
    void readMapTecplot(char *s, int &mapSize);
    void readMapGnuplot(char *s, int &mapSize);
    int  parseCommandLine(int argc, char **argv);
    void initData(char **argv, double *v, double **p, double *f0, double *finalv, int firstArg);
    void plotMap(char *s, int max, double **f);

    // Evaluate the command-line arguments
    firstArg = parseCommandLine(argc, argv); 

    // Allocate memory:
    v      = dalloc(o.Ndim);   // This is the 1-D array containing the points, NR3-style
    vlist  = d2alloc(o.Ndim+1, o.Ndim);
    f0     = dalloc(o.Ndim+1); // Initial function values at the simplex vertices
    finalv = dalloc(o.Ndim);

    // Initialize memory:
    initData(argv, v, vlist, f0, finalv, firstArg);

    // Optimize!
    finalVal = amoeba(vlist, f0, o.Ndim, tol, y, nEvals, 10000, finalv);

    plotMap((char *)"terrain.dat", o.mapSize, o.f);
    
    // And the results:
    printf("\nSuccess!  Mantel converged to a tolerance of %g in %d steps to a value "
	   "y = %16.8le with this vector:\n\n", 
	   tol, nEvals, finalVal);
    printf("[");
    for (i=0; i < o.Ndim; i++) 
	printf("%16.8le%s", finalv[i], i != (o.Ndim-1) ? ", " : "]\n\n");
    
    fclose(o.flog);
    if (o.dataMode == fileMap || o.dataMode == function) fclose(o.fplot);
    return(0);
}

//-----------------------------------------------------------------------------------

// Allocate memory and initialize the simplex prior to calling amoeba:
void initData(char **argv, double *v, double **vlist, double *f0, double *finalv, int firstArg) {
    int i, j;        // do-loop variables
    int I;
    double y(double *v);

    // fprintf(stderr, "firstArg = %d\n", firstArg);

    // Read the commandline parameters
    for (i=0; i < o.Ndim; i++) {
	I = i + firstArg;
	if (sscanf(argv[I], "%le", &(v[i])) != 1) {
	    fprintf(stderr, "Error interpreting %s as a number.\n", argv[I]);
	    exit(1);
	}
    }

    fprintf(stderr, "  {Finding initial vertex function values}\n");
    for (i=0; i < o.Ndim+1; i++) {
	for (j=0; j < o.Ndim; j++) {
	    vlist[i][j] = v[j];
	    if (j == i-1) vlist[i][j] *= 1.05;
	}
	f0[i] = y(vlist[i]);
    }

    fprintf(stderr, "initial coordinates = %g %g\n", v[0], v[1]);
}

int parseCommandLine(int argc, char **argv) {
    void usageError(char **argv);
    int firstNumericalArgumentIndex = 1;
    void readMap(char *s, int &mapSize);

    strcpy(o.logFile, "mantel.log");
    o.flog = safeopen((char *)o.logFile, (char *)"w");
    o.dataMode = commandLine; 

    if (argc == 1) usageError(argv);

    if (!strcmp(argv[1], "-S")) {
	o.dataMode = script;
	if (argc < 3) usageError(argv);
	strcpy(o.script, argv[2]);
	fprintf(stderr, "Using script '%s'\n", o.script);
	firstNumericalArgumentIndex += 2;
    } else if (!strcmp(argv[1], "-g")) {
	o.dataMode = fileMap;
	o.plotMode = gnuplot;
 	if (argc < 3) usageError(argv);
	strcpy(o.mapFile, argv[2]);
	firstNumericalArgumentIndex += 2;
    } else if (!strcmp(argv[1], "-t")) {
	o.dataMode = fileMap;
	o.plotMode = tecplot;
	if (argc < 3) usageError(argv);
	strcpy(o.mapFile, argv[2]);
	firstNumericalArgumentIndex += 2;
    } else if (!strcmp(argv[1], "-a")) {
	o.dataMode = function;
	firstNumericalArgumentIndex += 1;
    } else usageError(argv);

    if (o.dataMode == fileMap || o.dataMode == function) {
	if (o.dataMode == fileMap) readMap(o.mapFile, o.mapSize);
	o.fplot = safeopen((char *)"f.plt", (char *)"w"); // output file which contains the steps of the simplex
    }

    // Set Ndim, the number of dimensions (remember a simplex has N+1 vertices in an N dimensional space):
    o.Ndim = argc - firstNumericalArgumentIndex;

    printf("Using a %d-point simplex in an %d-dimensional space.\n", o.Ndim+1, o.Ndim);
    printf("Steps are recorded in the file '%s'\n\n", o.logFile);
    if (o.dataMode == commandLine) printf("Enter values for y(x1, ..., xn), or 'q' to quit.\n");
    return(firstNumericalArgumentIndex);
}

void usageError(char **argv) {
	fprintf(stderr, 
		"Error: Incorrect number of arguments.\n"
		"Usage: %s [-S script | -f infile | -a] x1 x2 ... xn\n\n"
		"You specify the initial set of parameters {xn}, and %s\n"
		"gives you successive parameter vectors and prompts you for\n"
		"the corresponding metric values y(x1, ..., xn), minimizing y in the process.\n\n"
		"-S: read in the metric values from mantel.in, write out the new vector to mantel.out,\n"
		"    and run script 'script' after each step\n"
		"-g: read in the function from a file (gnuplot format)\n"
		"-t: read in the function from a file (tecplot format)\n"
		"-a: optimize a hardcoded analytic function\n\n", 
		argv[0], argv[0]);
	exit(1);
}

void readMap(char *s, int &mapSize) {
    FILE *fp;
    int i, j;
    int numnls=0;
    double d;
    char c, clast;

    fp = safeopen((char *)s, (char *)"r");
    if (o.plotMode == tecplot) {
	queueup(fp, NULL, (char *)"=");
	fscanf(fp, "%d", &mapSize);
	while ((c=fgetc(fp)) != '\n');
    } else {
	// gnuplot format, which separates each i line with a blank line:
	// fp = nc(fp); // skip initial comments and white space
	c = '\0';
	do {
	    clast = c;
	    c = fgetc(fp);
	    if (c=='\n') { numnls++; /* fprintf(stderr, "[nl]"); */ }
	} while (!(c=='\n' && clast == '\n') && c != EOF);
	rewind(fp);
	mapSize = numnls-1;
    }
    fprintf(stderr, "Opening file \"%s\" and reading %dx%d array\n", 
	    s, mapSize, mapSize);
    o.f = d2alloc(mapSize, mapSize);
    for (i=0; i < mapSize; i++)
	for (j=0; j < mapSize; j++)
	    fscanf(fp, "%le %le %le", &d, &d, &(o.f[i][j]));
    fclose(fp);
}

void printvec(double *v, int d, int N) {
    int i;
    fprintf(stderr, "v%d = (", d);
    for (i=0; i < N; i++) 
	fprintf(stderr, "%g%s", v[i], i==N-1 ? ")\n" : ", ");
}

// Simplex minimization of a double-valued function "funk"
double amoeba(double **vlist,           // an array of ndim+1 vectors for the vertices of the simplex (ea. with ndim coords)
	      double *y,                // the initial values of the function at the vertices
	      int ndim,                 // the dimensionality of the space
	      double ftol,              // the tolerance for convergence
	      double (*funk)(double *), // function being optimized
	      int &nfunk,               // number of times the function was evaluated
	      int maxIters,             // max number of iterations
	      double *vfinal) {          // coordinates of the final optimized point

    int i, j,           // do-loop variables
	ilo, ihi, inhi, // index in p of the vector with the lowest function value (ilo), highest (ihi) 
	                // and next highest (inhi)
	mpts = ndim+1;  // number of simplex vertices
    double ytry, ysave, sum, rtol;
    void nrerror();
    double amotry(double **p, double *y, 
	      int ndim, double (*funk)(double *), int ihi, int &nfunk, 
		  double fac);
    bool goon = true;
    
    // The following three parameters determine how quickly the simplex moves and contracts. 
    double alpha = 1.0; // How far the high point gets relfected. A value of 1.0 preserves the simpelx volume
    double beta  = 0.5; // Size of a 1-D contract, used when new point is only better than the current second worst
    double gamma = 2.0; // How far the point gets extended if it gives a good result
    
    nfunk = 0;
    
    while (goon) {

	if (DEBUG) {
	    fprintf(stderr, "-----------------\n");
	    for (i=0; i < ndim+1; i++)
		printvec(vlist[i], i, ndim);
	    fprintf(stderr, "-----------------\n");
	}

	// Find the lowest (best), second-lowest adn highest points:
	ilo=0;
	// ihi = y[0]>y[1] ? (inhi=1,0) : (inhi=0,1); // rewritten because I dislike (most) obscure notation
	if (y[0] > y[1]) {
	    ihi = 0; inhi = 1;
	} else {
	    ihi = 1; inhi = 0;
	}
	for (i=0; i< mpts; i++) {
	    if (y[i] < y[ilo]) ilo=i;
	    if (y[i] > y[ihi]) {
		inhi = ihi;
		ihi  = i;
	    } else if (y[i] > y[inhi])
		if (i != ihi) inhi=i;
 	}

	// Fractional range from lowerst to highest:
	rtol = 2.0 * fabs(y[ihi] - y[ilo]) / (fabs(y[ihi]) + fabs(y[ilo]));

	if (rtol < ftol) {
	    goon = false; 
	} else if (nfunk >= maxIters) {
	    fprintf(stderr, "Max number of iterations exceeded in amoeba()");
	    goon = false;
	} else {
	    // Begin a new iteration. First, extrapolate by a factor alpha through the face of the simplex 
            // across from the hgih point, i.e., reflect the simplex from the high point:
	    fprintf(stderr, "  {Regular reflection}\n");
	    ytry=amotry(vlist, y, ndim, funk, ihi, nfunk, -alpha); // -alpha because it's a reflection
	    
	    if (ytry <= y[ilo]) {
		// Gives a result better than the best point, so try an additional extrapolation by a factor gamma:
		fprintf(stderr, "  {Looking promising--extending in the reflected direction}\n");
		ytry = amotry(vlist, y, ndim, funk, ihi, nfunk, gamma); // positive gamme because we are extending
		// in the same direction.
	    } else if (ytry >= y[inhi]) {
		// The reflected point is worse than the second highest, so look for an intermediate lower point, 
		// i.e., do a one-dimensional contraction
		ysave = y[ihi];
		fprintf(stderr, "  {One-dimensional contraction}\n");
		ytry  = amotry(vlist, y, ndim, funk, ihi, nfunk, beta);
		if (ytry >= ysave) {
		    // Can't seem to get rid of that high point. Better contract around the lowest (best) point.
		    // This is accomplished by replacing each of the points by the midpoint between that point and
		    // the low point. 
		    fprintf(stderr, "  {Performing a multidimensional contraction}\n");
		    for (i=0; i < mpts; i++) {
			if (i != ilo) {
			    for (j=0; j < ndim; j++) {
				vlist[i][j] = 0.5 * (vlist[i][j] + vlist[ilo][j]);
			    }
			    y[i] = (*funk)(vlist[i]);
			}
		    }
		    nfunk += ndim;
		    
		}
	    }
	}
    }

    // Find the index of the low point
    for (i=1, ilo = 0; i < ndim; i++)
	if (y[i] < y[ilo]) ilo = i;

    // Copy its coorinates to return to caller
    for (i=0; i < ndim; i++) vfinal[i] = vlist[ilo][i];

    // Return lowest function value found
    return(y[ilo]);
}

// Called by amoeba. Does the reflection (for negative fac) about the midpoint.
double amotry(double **vlist,            // list of vectors specifying each vertex
	      double *y,                 // list of function values at each vertex
	      int ndim,                  // dimensionality of the space
	      double (*funk)(double *),  // function being mimimized
	      int ihi,                   // index in p of the point with the highest value, the one being reflected
	      int &nfunk,                // number of times the function has been called
	      double f) {                // factor specifying the reflection/magnification; -1 is volume-preserving reflection
    int i, j;
    double fac1,fac2;
    double ytry; 
    double *vtry; // the new point being tried
    double *vmid; // the midpoint of all the points except that with the highest function value (i.e. the one we are trying
                  // to get rid of)
    
    if (DEBUG) {
	fprintf(stderr, "##-----------------\n");
	for (int i=0; i < ndim+1; i++)
	    printvec(vlist[i], i, ndim);
	fprintf(stderr, "##-----------------\n");
    }

    vmid = dalloc(ndim);
    vtry = dalloc(ndim);

    // Find the midpoint: vmid -> Sum{v_i for i != ihi} / ndim
    for (i=0, vmid[i]=0.0; i < ndim; i++)
	for (j=0; j < ndim+1; j++)
	    if (j != ihi) vmid[i] += vlist[j][i] / ((double) ndim);

    // Reflect the hi point across the midpoint: vtry = vmid + f * (vhi - vmid) 
    // (So if f==1 vtry->vhi; if f==-1 the point is reflected and the simplex volume remains the same.)
    for (i=0, vtry[i]=0.0; i < ndim; i++)
	vtry[i] = vmid[i] + f * (vlist[ihi][i] - vmid[i]);
    
    ytry = (*funk)(vtry);
    ++(nfunk);

    // If the point is better than the previous worst, keep it:
    if (ytry < y[ihi]) {
	y[ihi]=ytry;
	for (j=0; j < ndim; j++) {
	    vlist[ihi][j] = vtry[j];
	}
    }

    if (DEBUG) {
	fprintf(stderr, "________\n");
	printvec(vtry, -1, ndim);
	fprintf(stderr, "~~~~~~~~\n");
    }

    free(vtry);
    free(vmid);
    return(ytry);
}

// Bilinear interpolation on the unit square:
// https://en.wikipedia.org/wiki/Bilinear_interpolation
double bilinearInterp(double q00, double q10, double q01, double q11, double x, double y) {
    return((1.0-x) * ((1.0-y)*q00 + y*q01) + x * ((1.0-y)*q10 + y*q11));
}

double interpMap(double x, double y) {
    int i, j;
    double val;

    if (x < 0.0 || y < 0.0 || x >= (double)o.mapSize - 1.0 || y >= (double)o.mapSize - 1.0) 
	return(MYHUGE); // put a wall around the map
    else {
	i = (int)x;
	j = (int)y;
	val = bilinearInterp(o.f[i][j], o.f[i+1][j], o.f[i][j+1], o.f[i+1][j+1], x-floor(x), y-floor(y));
	return(val);
    }
}

// The function which evaluates y(x1, ..., xn)
double y(double *v) {
    int    i, tries=0, maxTries=10, varRead=0;
    double metric;
    double x, y;
    char   metricString[MAXSTR];
    FILE   *fp;
    static int iteration=0;
 
    if (o.dataMode == function) {
	x = v[0];
	y = v[1];
	metric = 2.0 * exp(-((x-2)*(x-2)+(y-2)*(y-2))/0.25)+sin(2.0*x) * sin(2.0*y);
    } else if (o.dataMode == fileMap) {
	metric = interpMap(v[0], v[1]);
    } else {
	if (o.dataMode == script) {
	    system("rm mantel.out");
	    fp = safeopen((char *)"mantel.out", (char *)"w");
	    for (i=0; i < o.Ndim; i++) fprintf(fp, "%11.4le\n", v[i]);
	    for (i=0; i < o.Ndim; i++) fprintf(stdout, "v[%d] = %11.4le\n", i, v[i]);
	    fprintf(stderr, "Executing script '%s'\n", o.script);
	    fclose(fp);
	    system(o.script);
	}
	
	fprintf(o.flog, "%03d ", iteration);
	printf("[%03d] y(", iteration++);
	fflush(o.flog);
	for (i=0; i < o.Ndim; i++) {
	    // printf("%11.4le%s", v[i], i == o.Ndim ? ") = ": ", ");
	    printf("%11.4le%s", v[i], i == (o.Ndim-1) ? ") = ": " ");
	    fprintf(o.flog, "%16.8le", v[i]);
	}
	
	if (o.dataMode == script) {
	    fp = safeopen((char *)"mantel.in", (char *)"r");
	    if (fscanf(fp, "%le", &metric) != 1) {
		printf("Error: contents of 'mantel.in' not a number.\n");
		fprintf(stderr, "metric: %g\n", metric);
		exit(1);
	    }
	    fclose(fp);
	    printf("metric: %g\n", metric);
	} else {
	    scanf("%s", metricString);
	    if (metricString[0] == 'q') {
		printf("\nExiting at user's request.\n");
		fprintf(o.flog, "\nExiting at user's request.\n");
		fclose(o.flog);
		exit(0);
	    }
	    
	    if (sscanf(metricString, "%le", &metric) != 1) 
		do {
		    printf("Error: I couldn't understand that as a number. Try again: ");
		    scanf("%s", metricString);
		    varRead = sscanf(metricString, "%le", &metric);
		} while (tries++ < maxTries && varRead != 1);
	    
	    if (tries == maxTries) {
		fprintf(stderr, "That's %d tries, for goodness' sake.  I give up.\n", tries);
		exit(1);
	    }
	}
    }

    fprintf(o.flog, "%16.8le\n", metric);
    fprintf(o.fplot, "%g %g %g\n", v[0], v[1], metric);

    return(metric);
}

void plotMap(char *s, int max, double **f) {
    int i, j;
    FILE *fp;
    double x, y, z, X, Y;

    bool gnuplot = false;

    fp = safeopen((char *)s, (char *)"w");
    fprintf(stderr, "Writing terrain plotting file \"%s\"\n", s);
    if (!gnuplot) fprintf(fp, "zone i=%d j=%d f=point\n", max, max);
    if (o.dataMode == function) {
	for (x=0; x < 40.0; x += 0.5) {
	    for (y=0; y < 40.0; y += 0.5)
		X = x/10.0; 
		Y = y/10.0;
		z = 4.0 * (2.0 * exp(-((X-2)*(X-2)+(Y-2)*(Y-2))/0.25)+sin(2.0*X) * sin(2.0*Y));
		fprintf(fp, "%g  %g %16.8le\n", x, y, z);
		if (gnuplot) fprintf(fp, "\n");
	    }
    } else {
	for (i=0; i < max; i++)
	    for (j=0; j < max; j++) {
		fprintf(fp, "%05d %05d %16.8le %16.8le\n", 
			i, j, f[i][j], interpMap((double)i, (double)j));
	    if (gnuplot) fprintf(fp, "\n");
	}
    }
    fclose(fp);
}

